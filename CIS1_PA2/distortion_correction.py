# -*- coding: utf-8 -*-
"""distortion_correction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gglk8QCSftUUW1lES8tGVs3g-WG2nWsq
"""

import numpy as np
import glob
from distort_calibration import *
from cartesian import*
from registration_3d import*
from optical_tracking import*
from em_tracking import *
from eval import *
from pathlib import Path
import argparse


# transform points to a number within the range of 0 to 1 in order to fit inside of Bern matrix
#X: The input data
#qmin, qmax: boundaries
def scale( X, X_min, X_max ):
    
    return ((X - X_min) / np.abs(X_max - X_min))

def get_Bern_comp(N, k, v):
    
    n_k = combinations(N, k)
    Bern_Nkv = (n_k * np.power((1 - v), (N - k))) * np.power(v, k)
    return Bern_Nkv

def Berntensor_matrix( points , qmin, qmax, order ):
#This function is used to build the bernstein polynomials in tensor form
#points: The input data which is often obtained from sensors and require distortion correction
#qmin, qmax: boundaries used for scaling points
#order: The order to which the bern matrix is calculated. the common number used in this assignment should be 5.
#

    scaled_points = scale( points , qmin, qmax )
    scaled_x = scaled_points[:, 0].reshape( ( -1, 1 ) )
    scaled_y = scaled_points[:, 1].reshape( ( -1, 1 ) )
    scaled_z = scaled_points[:, 2].reshape( ( -1, 1 ) )
    size = order + 1
    bern_matrix = np.zeros( ( points.shape[0], int(math.pow(size, 3)) ) )
    
    for i in range( size ):
        for j in range( size ):
            for k in range( size ):
                
                F_ijk = (get_Bern_comp(5, i, scaled_x) * 
                get_Bern_comp(5, j, scaled_y) *
                get_Bern_comp(5, k, scaled_z) )
                #we need to change the shape from (k,1) to (k,)
                F_ijk = F_ijk.reshape(-1,)
                bern_matrix[:, int(i * math.pow(size, 2) + j * size + k)] = F_ijk
    
    return bern_matrix

#Calculates c_k through least squares.
#q: Sensor data requiring correction
#p: ground truth
#order: Order of Bern polynomials, 5 is the default value here.
def distortion_correction( q, p, order=5):

    qmin = np.min( q )      
    qmax = np.max( q )
    #print(qmin)
    #print(qmax)
    
    A = Berntensor_matrix( q, qmin, qmax, order )
    B = p
    
    # AX = B
    X = np.linalg.lstsq(A, B, rcond=None)[0]

    #print("AX-B max error: ",np.max(A@X-B))
    return X, qmin, qmax

def data_correction(data, X, Nframes, Ng, qmin, qmax):
#data: Data which requires correcting
#X: The matrix c_k
#Nframes, Ng: Numbers from data files defining data frame sizes and numbers
#qmin, qmax: values of max and min used during scaling and putting inside Bern matrix.
    empivot_corrected = []
    for i in range(Nframes):
        if i == 0:
            B_mat = Berntensor_matrix(data[i*Ng:(i+1) * Ng, :], qmin, qmax, 5)
            empivot_corrected = B_mat @ X
        # print(empivot_corrected)
        else:
            B_mat = Berntensor_matrix(data[i*Ng:(i+1) * Ng, :], qmin, qmax, 5)
            tmp_cor = B_mat @ X
            empivot_corrected = np.concatenate((empivot_corrected, tmp_cor), 0)
    return empivot_corrected